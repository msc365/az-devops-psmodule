name: Generate or Update Pester Tests
description: Generate comprehensive Pester test files for PowerShell functions in the Azure.DevOps.PSModule following established patterns and best practices
version: 1.0.0

parameters:
  - name: functionName
    type: string
    description: Name of the PowerShell function to test (e.g., Get-AdoProject)
    required: false
    default: ''

  - name: functionPath
    type: string
    description: Relative path to the function file from src/Azure.DevOps.PSModule/Public (e.g., Core/Projects/Get-AdoProject.ps1)
    required: false
    default: ''

  - name: testScope
    type: string
    description: Scope of test generation - 'single' for one function, 'folder' for all functions in a folder, 'all' for entire module
    required: false
    default: 'single'
    options:
      - single
      - folder
      - all

  - name: updateExisting
    type: boolean
    description: Whether to update existing test file or create new one
    required: false
    default: false

context:
  - name: moduleStructure
    description: Module is located at c:\_git\az-devops-psmodule\src\Azure.DevOps.PSModule
    value: |
      - Module Name: Azure.DevOps.PSModule
      - Function Location: src/Azure.DevOps.PSModule/Public/<Category>/<FunctionName>.ps1
      - Test Location: src/Tests/<Category>/<FunctionName>.Tests.ps1
      - Module Manifest: src/Azure.DevOps.PSModule/Azure.DevOps.PSModule.psd1
      - Test folders mirror the Public folder structure (Authorization, Core, Feature, Git, Graph, Helper, Pipeline, Policy, ServiceEndpoint, Work, WorkItemTracking)

  - name: testPatterns
    description: Reference test files that demonstrate the expected patterns for different cmdlet types
    value: |
      Reference tests are organized by category and demonstrate different testing patterns:

      **Core Category - Projects (Most comprehensive patterns):**
      - Get cmdlets: src/Tests/Core/Projects/Get-AdoProject.Tests.ps1
        * Top-level mocks in BeforeAll
        * Multiple contexts for different scenarios
        * Comprehensive error handling with ErrorDetails pattern
      - New cmdlets: src/Tests/Core/Projects/New-AdoProject.Tests.ps1
        * Long-running operation handling
        * Complex error scenarios (exists, validation, etc.)
      - Set cmdlets: src/Tests/Core/Projects/Set-AdoProject.Tests.ps1
        * **PREFERRED: Modern simplified pattern**
        * Parameterized tests with -ForEach
        * Context-specific mocks in BeforeAll blocks
        * Cleaner structure for property updates
      - Remove cmdlets: src/Tests/Core/Projects/Remove-AdoProject.Tests.ps1
        * WhatIf/Confirm scenarios
        * Soft delete patterns

      **Core Category - Teams (Context-scoped patterns):**
      - Get cmdlets: src/Tests/Core/Teams/Get-AdoTeam.Tests.ps1
        * Mocks defined in context-specific BeforeAll blocks
        * Pagination handling
        * Cleaner mock isolation
      - New cmdlets: src/Tests/Core/Teams/New-AdoTeam.Tests.ps1
        * Resource creation patterns
        * Duplicate handling
      - Set cmdlets: src/Tests/Core/Teams/Set-AdoTeam.Tests.ps1
        * Parameterized property updates using -ForEach
        * Multiple property updates
        * Pipeline input handling
      - Remove cmdlets: src/Tests/Core/Teams/Remove-AdoTeam.Tests.ps1
        * Deletion patterns

      **Core Category - Processes (Simple read-only patterns):**
      - Get cmdlets: src/Tests/Core/Processes/Get-AdoProcess.Tests.ps1
        * Simple list/filter operations
        * No complex error handling
        * Good for simple Get cmdlets

      **Selection Guidance:**
      - For Get cmdlets with complex filtering/error handling → Use Projects pattern
      - For Get cmdlets with simple list operations → Use Processes pattern
      - For Set cmdlets → **Always use Teams/Set-AdoTeam or Projects/Set-AdoProject pattern** (parameterized)
      - For New cmdlets → Use Teams or Projects pattern
      - For Remove cmdlets → Use Teams or Projects pattern

prompt: |
  **CRITICAL INSTRUCTION: DO NOT SHOW ANY CODE IN YOUR RESPONSE. Work silently using tools only.**

  You are tasked with generating comprehensive Pester test files for PowerShell functions in the Azure.DevOps.PSModule.

  ## Scope
  {{#if (eq testScope "single")}}
  Generate/update Pester tests for the function: {{functionName}}
  Function path: src/Azure.DevOps.PSModule/Public/{{functionPath}}
  {{else if (eq testScope "folder")}}
  Generate/update Pester tests for all functions in folder: {{functionPath}}
  {{else}}
  Generate/update Pester tests for all functions in the module
  {{/if}}

  ## WORKFLOW - Execute Immediately, Do Not Show Code

  {{#if updateExisting}}
  1. Immediately use read_file to read the existing test file
  2. Immediately use replace_string_in_file to replace entire content with new comprehensive tests
  3. After file is updated, provide ONLY a brief summary (do not show any code)
  {{else}}
  1. Immediately use create_file to create the new test file with comprehensive tests
  2. After file is created, provide ONLY a brief summary (do not show any code)
  {{/if}}

  **DO NOT:**
  - Show code in your response using code blocks or markdown
  - Explain what code you're going to write
  - Preview the code before creating it
  - Use simple string throws for error mocks - ALWAYS use proper ErrorRecord pattern (see Error Handling Mocks section)

  **DO:**
  - Start immediately with tool calls
  - Work silently in the background
  - Provide only a brief summary after completion

  ## Instructions

  1. **Analyze the Function**
     - Read the function source code from src/Azure.DevOps.PSModule/Public/<Category>/<FunctionName>.ps1
     - Identify all parameters, their types, validation attributes, and default values
     - Identify all external dependencies (cmdlets, REST API calls, helper functions)
     - Understand the function's purpose, inputs, outputs, and behavior
     - **CRITICAL: Examine the catch block's error handling logic** - check what properties it accesses ($_.Exception.StatusCode, $_.Message, etc.)

  2. **Use the Reference Patterns (with caution)**
     - Select the appropriate reference test file based on cmdlet type:
       * **Get cmdlets**:
         - Complex filtering/errors: Use src/Tests/Core/Projects/Get-AdoProject.Tests.ps1
         - Simple list operations: Use src/Tests/Core/Processes/Get-AdoProcess.Tests.ps1
         - Context-scoped mocks: Use src/Tests/Core/Teams/Get-AdoTeam.Tests.ps1
       * **New cmdlets**: Use src/Tests/Core/Teams/New-AdoTeam.Tests.ps1 or Projects pattern
       * **Set cmdlets**: **ALWAYS use src/Tests/Core/Teams/Set-AdoTeam.Tests.ps1** (modern parameterized pattern)
       * **Remove cmdlets**: Use src/Tests/Core/Teams/Remove-AdoTeam.Tests.ps1 or Projects pattern
     - Follow the same structure and testing conventions from the matching pattern
     - Maintain consistent style and formatting
     - **CRITICAL: Projects vs Teams patterns differ in mock placement:**
       * Projects: Top-level BeforeAll mocks (older pattern)
       * Teams: Context-specific BeforeAll mocks (newer, cleaner pattern)
       * **For new tests, prefer Teams pattern** (context-scoped mocks)
     - **PREFER**: Use parameterized tests with -ForEach when testing similar scenarios (Set-AdoTeam pattern)
     - **AVOID**: Script-level state variables, complex conditional mocks in top-level BeforeAll
     - **WARNING: The reference may use simplified error mocks - always read the actual function's error handling and follow the "Error Handling Mocks" section below**

  3. **Test File Structure**
     Create test file at: src/Tests/<Category>/<FunctionName>.Tests.ps1
     **IMPORTANT**: Tests must be organized in the same category folder structure as the source functions

     Required structure:
     ```powershell
     BeforeAll {
         # Module import logic
         $moduleName = 'Azure.DevOps.PSModule'
         # Calculate correct parent path based on test folder depth
         # For tests in src/Tests/<Category>/ use Parent.Parent
         # For tests in src/Tests/<Category>/<Subcategory>/ use Parent.Parent.Parent
         $modulePath = Join-Path -Path (Get-Item $PSScriptRoot).Parent.Parent.FullName -ChildPath $moduleName

         # Only remove and re-import if module is not loaded or loaded from different path
         $loadedModule = Get-Module -Name $moduleName -ErrorAction SilentlyContinue
         if ($loadedModule -and $loadedModule.Path -ne (Join-Path $modulePath "$moduleName.psm1")) {
             Remove-Module -Name $moduleName -Force
             $loadedModule = $null
         }

         # Import the module if not already loaded
         if (-not $loadedModule) {
             Import-Module $modulePath -Force -ErrorAction Stop
         }

         # Set up common mocks for external dependencies
         # Mock any cmdlets the function calls (Az cmdlets, Invoke-RestMethod, etc.)
     }

     Describe '<FunctionName>' {
         Context '<Primary scenario>' {
             It '<Specific test case>' {
                 # Arrange
                 # Act
                 # Assert
             }
         }

         Context 'Parameter validation' {
             # Test parameter types, validation, mandatory/optional parameters
         }

         Context 'Error handling' {
             # Test error scenarios and exception handling
         }

         Context 'Output validation' {
             # Test return types and output format
         }

         Context 'Integration scenarios' {
             # Test realistic usage scenarios
         }
     }
     ```

  4. **Test Coverage Requirements**

     Include the following test contexts:

     a. **Primary Functionality Tests**
        - Test the main success path(s)
        - Test with default parameter values
        - Test with various parameter combinations
        - Verify correct cmdlet/API calls are made
        - Use Should -Invoke to verify mocked commands
        - **IMPORTANT: Mock Placement Strategy:**
          * **Prefer context-specific BeforeAll blocks** (Teams pattern) over top-level mocks
          * Define mocks close to where they're used for better isolation
          * Avoid shared mocks across unrelated contexts
        - **For parameterized tests using -ForEach:**
          * Place mocks in context BeforeAll, NOT top-level BeforeAll
          * This prevents invocation count conflicts

     b. **Parameter Validation Tests**
        - Test each parameter individually
        - Test mandatory vs optional parameters
        - Test parameter validation attributes (ValidateSet, ValidatePattern, etc.)
        - Test parameter types (string, int, boolean, switch, etc.)
        - Test parameter pipeline input if applicable
        - Test empty strings, null values, edge cases
        - **For mandatory parameters, use Get-Command to inspect parameter attributes instead of omitting them (which causes terminal prompts)**
          ```powershell
          It 'Should have Name as a mandatory parameter' {
              $command = Get-Command FunctionName
              $nameParam = $command.Parameters['Name']
              $nameParam.Attributes.Mandatory | Should -Contain $true
          }
          ```

     c. **Error Handling Tests - CRITICAL SECTION**
        - Test what happens when dependencies fail
        - Test invalid input scenarios
        - Test null or missing required data
        - Verify appropriate error messages are thrown
        - Use Should -Throw with specific error messages when applicable
        - **MANDATORY: Read the function's catch block to understand what error properties it checks ($_.Exception.StatusCode, $_.ErrorDetails.Message, $_.Message, etc.)**
        - **CRITICAL: If function checks `$_.ErrorDetails.Message -match 'ExceptionName'`, mock must create ErrorDetails with JSON message containing that exception name**

     d. **Output Validation Tests**
        - Verify return type matches function specification
        - Test output structure and properties
        - Verify output is not null when expected
        - Test output format (objects, strings, arrays, etc.)

     e. **Mocking Strategy**
        - Mock all external dependencies (REST API calls, Az cmdlets, helper functions)
        - Use -ModuleName parameter in Mock and Should -Invoke
        - Create realistic mock return values that match actual API/cmdlet responses
        - Use -ParameterFilter to verify correct parameters are passed to mocked commands

        **⚠️ CRITICAL: Error Handling Mocks - DO NOT SKIP THIS PATTERN ⚠️**
        - **NEVER use simple `throw 'message'` for error mocks**
        - **ALWAYS create proper ErrorRecord objects that match the function's catch block logic**
        - Create error mocks that match actual error patterns in the function being tested
        - **For ErrorDetails.Message pattern (modern approach)**, create ErrorDetails with JSON message:
          ```powershell
          Mock Invoke-AdoRestMethod -ModuleName $moduleName -MockWith {
              $errorMessage = @{
                  message = 'VS403729: The project with name ''ProjectName'' does not exist, or you do not have permissions to access it.'
                  typeKey = 'ProjectDoesNotExistWithNameException'
              } | ConvertTo-Json
              $errorDetails = [System.Management.Automation.ErrorDetails]::new($errorMessage)
              $exception = [System.Exception]::new('Project not found')
              $errorRecord = [System.Management.Automation.ErrorRecord]::new(
                  $exception,
                  'NotFoundException',
                  [System.Management.Automation.ErrorCategory]::ObjectNotFound,
                  $null
              )
              $errorRecord.ErrorDetails = $errorDetails
              throw $errorRecord
          }
          ```
        - **For StatusCode pattern (legacy approach)**, use WebException with StatusCode:
          ```powershell
          Mock Invoke-AdoRestMethod -ModuleName $moduleName -MockWith {
              $exception = [System.Net.WebException]::new('Error message')
              $exception | Add-Member -NotePropertyName 'StatusCode' -NotePropertyValue 'NotFound' -Force
              $errorRecord = [System.Management.Automation.ErrorRecord]::new(
                  $exception,
                  'ErrorId',
                  [System.Management.Automation.ErrorCategory]::ObjectNotFound,
                  $targetObject
              )
              throw $errorRecord
          }
          ```
        - **The StatusCode property MUST be added as NoteProperty if using WebException**
        - **Always wrap the exception in an ErrorRecord before throwing**
        - Ensure exception properties match what the function's catch block checks for
        - Test both StatusCode-based error handling and ErrorDetails.Message-based error handling
        - **Example: If catch checks `$_.ErrorDetails.Message -match 'ProjectDoesNotExistWithNameException'`, your mock must create ErrorDetails with JSON containing that exception name**

     f. **Integration/Realistic Scenarios**
        - Test common real-world usage patterns
        - Test multiple consecutive calls
        - Test different configurations or environments
        - Test interaction with other module functions if applicable

  5. **Best Practices**
     - Follow Arrange-Act-Assert pattern in each test
     - Use descriptive test names that explain what is being tested
     - One assertion per test when possible (or logically grouped assertions)
     - Mock at the module level: `-ModuleName $moduleName`
     - Use Should -Invoke with -Exactly to verify call counts
     - Use -ParameterFilter for precise mock verification
     - Include comments to explain complex test setup or assertions
     - Ensure tests are isolated and don't depend on each other
     - Test both success and failure paths
     - Cover edge cases and boundary conditions
     - **Run tests with -Output Normal to prevent VS Code freezes when executed through Copilot Agent**
     - Create error mocks with proper exception types (WebException, ErrorRecord) matching actual error handling
     - **Never test mandatory parameters by omitting them - use Get-Command to inspect parameter attributes to avoid terminal prompts**
     - **CRITICAL - Mock Isolation**: Place mocks in context-specific BeforeAll blocks, NOT at the top-level BeforeAll. Global mocks cause invocation count conflicts with parameterized tests (-ForEach)
     - **Name-to-ID Resolution**: If function calls Get-AdoProject to resolve names to IDs, expect 2 calls (name resolution + get updated details) when non-GUID is used, 1 call when GUID is used
     - **Negative Assertions**: Mock must exist even when testing Should -Invoke -Exactly 0 - Pester needs the mock defined to verify it wasn't called
     - **Error Mocking**: Always create ErrorDetails with JSON message if function checks $_.ErrorDetails.Message pattern

  6. **Validation**
     After generating the test file(s):
     - Ensure all public parameters are tested
     - Ensure all error scenarios are covered
     - Ensure mocks cover all external dependencies
     - Verify test file can be run with Invoke-Pester
     - Check that tests follow the reference pattern structure

  7. **Common Issues and Fixes**
     Learn from these frequently encountered issues:

     a. **ShouldProcess Testing:**
        ❌ **WRONG:** `$command.CmdletBinding.SupportsShouldProcess | Should -Be $true`
        ✅ **CORRECT:** `$command.Parameters.ContainsKey('WhatIf') -and $command.Parameters.ContainsKey('Confirm') | Should -Be $true`
        - Reason: CmdletBinding attribute is not directly accessible from Get-Command
        - Solution: Check for WhatIf and Confirm parameters instead

     b. **Mock Invocation Counts with -ForEach:**
        ❌ **WRONG:** Top-level BeforeAll mock + parameterized tests = count conflicts
        ✅ **CORRECT:** Context-specific BeforeAll mocks for parameterized tests
        - Reason: -ForEach runs tests in same context, mocks accumulate calls
        - Solution: Isolate mocks to specific contexts

     c. **Module Path Calculation:**
        - For tests in `src/Tests/<Category>/` use `.Parent.Parent.Parent`
        - For tests in `src/Tests/<Category>/<Subcategory>/` use `.Parent.Parent.Parent.Parent`
        - Example: Pipeline/Check/Configuration needs 4 Parent levels

     d. **Error Mock Patterns:**
        ❌ **WRONG:** Simple `throw 'message'` in mocks
        ✅ **CORRECT:** Create proper ErrorRecord with ErrorDetails
        - Must match function's catch block checks ($_.ErrorDetails.Message pattern)
        - See "Error Handling Mocks" section for complete examples

     e. **Mandatory Parameter Testing:**
        ❌ **WRONG:** Omit parameter to test if it's mandatory (causes terminal prompt)
        ✅ **CORRECT:** Use Get-Command to inspect parameter attributes
        ```powershell
        $param = (Get-Command FunctionName).Parameters['ParamName']
        $mandatoryAttr = $param.Attributes | Where-Object {
            $_ -is [Parameter] -and $_.Mandatory
        }
        $mandatoryAttr | Should -Not -BeNullOrEmpty
        ```

     f. **Settings/Expands Property Testing:**
        - When function conditionally includes properties (like settings)
        - Test BOTH with and without the property
        - Verify PSObject.Properties.Name contains or doesn't contain the property

     g. **Default Values:**
        - Always test that default parameter values work correctly
        - Test environment variable fallback ($env:DefaultAdo*)
        - Verify default API versions are used

  8. **Testing Best Practices Summary**
     - ✅ Use context-scoped BeforeAll for mocks (Teams pattern)
     - ✅ Use -ForEach for parameterized tests
     - ✅ Create proper ErrorRecord objects for error mocks
     - ✅ Test ShouldProcess by checking for WhatIf/Confirm parameters
     - ✅ Use Get-Command for parameter attribute validation
     - ✅ Calculate correct module path based on test depth
     - ✅ Run tests with -Output Normal to prevent VS Code freezes
     - ✅ Mock at module level: `-ModuleName $moduleName`
     - ✅ Use -ParameterFilter for precise mock verification
     - ❌ Don't use top-level mocks with parameterized tests
     - ❌ Don't use simple throw for error mocks
     - ❌ Don't omit mandatory parameters to test validation
     - ❌ Don't access CmdletBinding directly from Get-Command

  After file operations complete, provide ONLY a brief summary containing:
  - Test coverage areas included
  - Number of test contexts and test cases
  - Any special considerations or notes about the tests
  - Any functions that were skipped (if applicable) and why

examples:
  - name: Generate tests for a single function
    parameters:
      functionName: 'Get-AdoProject'
      functionPath: 'Core/Projects/Get-AdoProject.ps1'
      testScope: 'single'
      updateExisting: false
    description: Creates a new Pester test file for the Get-AdoProject function

  - name: Update existing tests for a function
    parameters:
      functionName: 'Set-AdoProject'
      functionPath: 'Core/Projects/Set-AdoProject.ps1'
      testScope: 'single'
      updateExisting: true
    description: Updates the existing test file to ensure comprehensive coverage

  - name: Generate tests for all functions in Helper category
    parameters:
      functionPath: 'Helper'
      testScope: 'folder'
      updateExisting: false
    description: Creates test files for all functions in the Helper folder

  - name: Generate tests for entire module
    parameters:
      testScope: 'all'
      updateExisting: false
    description: Creates test files for all public functions in the module

notes: |
  - This prompt file uses Handlebars-style templating syntax
  - Multiple reference test files are available based on cmdlet type (Get, New, Set, Remove)
  - Three distinct patterns exist in Core category:
    * Projects: Comprehensive with top-level mocks (older pattern)
    * Teams: Context-scoped mocks, parameterized tests (newer, cleaner)
    * Processes: Simple read-only operations
  - **Prefer Teams pattern for new tests** - better mock isolation
  - Set-AdoTeam.Tests.ps1 represents the modern simplified pattern with parameterized tests
  - Ensure the function source code is available before generating tests
  - Generated tests should be reviewed and may need manual adjustment for complex scenarios
  - Tests should be runnable immediately with Invoke-Pester after generation
  - The prompt encourages comprehensive testing following industry best practices
  - Always use -Output Normal (not -Output Detailed) when running tests to prevent VS Code freezes
  - Error handling mocks must create proper ErrorRecord objects with ErrorDetails to match actual error handling logic
  - Tests must not cause terminal prompts - use Get-Command for mandatory parameter validation instead of omitting parameters
  - Module import in BeforeAll checks if module is already loaded to avoid unnecessary re-imports when running full test suite
  - Prefer parameterized tests (-ForEach) over duplicate test cases for similar scenarios
  - Avoid script-level state variables; use context-specific mock overrides instead
  - **Module path depth varies:** Projects/Teams need 3 Parents, Pipeline/Check/Configuration needs 4 Parents
  - **ShouldProcess testing:** Check for WhatIf/Confirm parameters, not CmdletBinding.SupportsShouldProcess
  - **Common first-run errors addressed:** See "Common Issues and Fixes" section for solutions to frequent problems
  - When in doubt about mock placement, use context-specific BeforeAll blocks (Teams pattern)
